在 React Fiber 架构中，判断“函数执行时间不够，需要中断”的核心机制是**时间切片（Time Slicing）**，主要依赖浏览器的调度能力，比如 `requestIdleCallback`、`MessageChannel` 等。

### 具体原理

1. **时间片分割**  
   React 会把渲染任务拆分成很多小单元（Fiber 节点），每次只处理一小部分。

2. **判断是否需要中断**  
   在每个小单元执行时，React 会检查当前帧还剩多少时间。如果时间快用完了，就会“中断”本次任务，把控制权还给浏览器，等下次有空闲再继续。

3. **如何判断时间是否足够**  
   - 早期用 `requestIdleCallback`，通过 `deadline.timeRemaining()` 判断剩余时间。
   - 现在主流用 `MessageChannel` 实现更高精度的任务调度，并通过记录每帧开始的时间和当前时间，计算是否超出阈值（如 5ms、16ms）。
   - 如果超时，React 会中断渲染，等浏览器空闲时再恢复。

4. **中断与恢复**  
   - 如果发现时间不够，React 会保存当前 Fiber 树的遍历进度。
   - 下次调度时，从上次中断的地方继续。

### 代码层面（简化伪代码）

```js
function workLoop(deadline) {
  while (nextUnitOfWork && deadline.timeRemaining() > 1) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  }
  if (nextUnitOfWork) {
    requestIdleCallback(workLoop);
  }
}
```

### 总结

React 通过“时间切片”+“调度器”机制，实时判断当前帧剩余时间，时间不够就中断，保证主线程不会被长任务阻塞，从而实现流畅的用户体验。

**说明：**
- 每次 workLoop 只处理一小部分任务（一个或几个 Fiber 节点）
- 如果时间快用完了（`deadline.timeRemaining() <= 1`），就中断，等下次空闲再继续
- 这样保证主线程不会被长任务阻塞，页面始终流畅

这就是 React Fiber 时间切片和中断的核心代码思想。