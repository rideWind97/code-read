## 🌐 什么是事件流？

当用户触发一个事件（如点击按钮），这个事件并不会只作用于目标元素，而是在 DOM 树中经历一个 **传播过程**，这个过程称为 **事件流**。

事件流分为三个阶段：

### 🔢 三个阶段（按顺序执行）


| 阶段                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 1. 捕获阶段（Capture Phase） | 事件从`window` → `document` → 逐级向下，直到目标元素的父级 |
| 2. 目标阶段（Target Phase）  | 事件到达目标元素本身                                         |
| 3. 冒泡阶段（Bubble Phase）  | 事件从目标元素逐级向上传播回`window`                         |

---

## 🎯 图示：事件传播路径

假设 HTML 结构如下：

```html
<div id="outer">
  <div id="inner">
    <button id="btn">点击我</button>
  </div>
</div>
```

当你点击 `<button id="btn">` 时，事件传播顺序是：

```
1. window        ↘
2. document       ↘
3. html            ↘
4. body            ↘
5. #outer          ↘
6. #inner          ↘
7. #btn     → 目标阶段（Target）
8. #inner          ↗
9. #outer          ↗
10. body           ↗
11. html           ↗
12. document       ↗
13. window        ↗

        ↓
    捕获阶段     →     冒泡阶段
```

---

## 🧩 JavaScript 中如何监听不同阶段？

使用 `addEventListener` 的第三个参数：

```js
element.addEventListener(event, handler, options)
```

### ✅ 第三个参数可以是：

- `false`（默认）：在 **冒泡阶段** 执行
- `true`：在 **捕获阶段** 执行
- `{ capture: true/false, once, passive }`：对象形式配置

---

### ✅ 示例代码

```js
const outer = document.getElementById('outer');
const inner = document.getElementById('inner');
const btn = document.getElementById('btn');

// 捕获阶段监听
outer.addEventListener('click', () => {
  console.log('捕获：outer');
}, true);

inner.addEventListener('click', () => {
  console.log('捕获：inner');
}, true);

btn.addEventListener('click', () => {
  console.log('目标：btn');
});

// 冒泡阶段监听（默认）
inner.addEventListener('click', () => {
  console.log('冒泡：inner');
}, false);

outer.addEventListener('click', () => {
  console.log('冒泡：outer');
}, false);
```

### 🔥 点击按钮时输出：

```
捕获：outer
捕获：inner
目标：btn
冒泡：inner
冒泡：outer
```

---

## 🛑 事件控制方法

### 1. `event.stopPropagation()`

- 阻止事件继续在 **当前阶段** 向上传播（冒泡）或向下（捕获）
- 但不会阻止同一元素上的其他监听器执行

```js
btn.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('按钮被点击，阻止冒泡');
});
```

👉 结果：`outer` 和 `inner` 的冒泡监听器不会触发。

---

### 2. `event.stopImmediatePropagation()`

- 不仅阻止传播，还阻止 **同一元素上后续的监听器执行**

```js
btn.addEventListener('click', () => {
  console.log('第一个监听器');
});

btn.addEventListener('click', (e) => {
  e.stopImmediatePropagation();
  console.log('第二个监听器（阻止后续）');
});

btn.addEventListener('click', () => {
  console.log('第三个监听器'); // ❌ 不会执行
});
```

---

### 3. `event.preventDefault()`

- 阻止默认行为（如链接跳转、表单提交）
- 不影响事件传播

```js
link.addEventListener('click', (e) => {
  e.preventDefault(); // 阻止跳转
});
```

---

## ⚠️ 注意事项


| 情况                   | 说明                                                                      |
| ---------------------- | ------------------------------------------------------------------------- |
| 表单元素（如`input`）  | 有些事件不冒泡（如`focus`, `blur`），可用 `focusin`/`focusout` 替代       |
| `window` 和 `document` | 也能绑定事件，常用于全局监听（如空闲检测）                                |
| 事件委托               | 利用冒泡机制，将事件监听绑定到父元素，处理子元素事件                      |
| 被动事件（passive）    | `passive: true` 提高性能（尤其移动端滚动），但不能调用 `preventDefault()` |

---

## ✅ 实际应用场景


| 场景                   | 使用方式                                                              |
| ---------------------- | --------------------------------------------------------------------- |
| 下拉菜单点击外部关闭   | 在`document` 捕获或冒泡阶段监听，判断点击是否在菜单外                 |
| 事件委托（如动态列表） | 在父容器监听`click`，利用冒泡处理子项                                 |
| 阻止弹窗关闭           | 点击弹窗内容时`stopPropagation()`，防止触发背景关闭                   |
| 全局空闲检测           | 监听`window` 上的 `mousemove`、`keydown` 等，即使局部阻止冒泡也能捕获 |

---

## ✅ 总结：事件流三阶段


| 阶段     | 传播方向         | 是否可监听      | 典型用途           |
| -------- | ---------------- | --------------- | ------------------ |
| 捕获阶段 | `window` → 目标 | `capture: true` | 早期拦截、权限控制 |
| 目标阶段 | 目标元素         | 是              | 正常处理事件       |
| 冒泡阶段 | 目标 →`window`  | 默认            | 事件委托、简化绑定 |

---

📌 **一句话记住**：

> 事件从外向内“捕获”，到达目标后，再从内向外“冒泡”。

掌握事件流，你就掌握了 DOM 事件的“交通规则” 🚦

需要我画一个图解或提供可运行的 CodePen 示例吗？
