# 常见设计模式详解

设计模式是解决软件设计问题的经典解决方案。以下是前端开发中最常见的设计模式：

## 1. 单例模式 (Singleton Pattern)

确保一个类只有一个实例，并提供全局访问点。

### 1.1 饿汉式单例 (Eager Singleton)

在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。

```javascript
// 饿汉式单例 - 立即初始化
class EagerSingleton {
    // 在类加载时就创建实例
    static instance = new EagerSingleton();
  
    constructor() {
        if (EagerSingleton.instance) {
            return EagerSingleton.instance;
        }
      
        this.data = [];
        console.log('饿汉式单例已创建');
    }
  
    static getInstance() {
        return EagerSingleton.instance;
    }
  
    addData(item) {
        this.data.push(item);
    }
  
    getData() {
        return this.data;
    }
}

// 模块模式实现饿汉式单例
const ConfigManager = (function() {
    // 立即创建实例
    const instance = {
        apiUrl: 'https://api.example.com',
        timeout: 5000,
        getConfig() {
            return { apiUrl: this.apiUrl, timeout: this.timeout };
        }
    };
  
    return {
        getInstance() {
            return instance;
        }
    };
})();

// 测试饿汉式单例
console.log('=== 饿汉式单例测试 ===');
const eager1 = EagerSingleton.getInstance();
const eager2 = EagerSingleton.getInstance();
console.log('饿汉式单例相等:', eager1 === eager2); // true

const config1 = ConfigManager.getInstance();
const config2 = ConfigManager.getInstance();
console.log('配置管理器相等:', config1 === config2); // true
```

**饿汉式特点：**

- ✅ 线程安全（类加载时就初始化）
- ✅ 获取实例速度快
- ❌ 类加载慢，占用内存
- ❌ 无法延迟初始化

### 1.2 懒汉式单例 (Lazy Singleton)

在第一次使用时才创建实例，延迟加载。

```javascript
// 懒汉式单例 - 延迟初始化
class LazySingleton {
    static instance = null;
  
    constructor() {
        if (LazySingleton.instance) {
            return LazySingleton.instance;
        }
      
        this.data = [];
        LazySingleton.instance = this;
        console.log('懒汉式单例已创建');
        return this;
    }
  
    static getInstance() {
        if (!LazySingleton.instance) {
            LazySingleton.instance = new LazySingleton();
        }
        return LazySingleton.instance;
    }
  
    addData(item) {
        this.data.push(item);
    }
  
    getData() {
        return this.data;
    }
}

// 模块模式实现懒汉式单例
const LazyConfigManager = (function() {
    let instance = null;
  
    function createInstance() {
        return {
            apiUrl: 'https://api.example.com',
            timeout: 5000,
            getConfig() {
                return { apiUrl: this.apiUrl, timeout: this.timeout };
            }
        };
    }
  
    return {
        getInstance() {
            if (!instance) {
                instance = createInstance();
                console.log('懒汉式配置管理器已创建');
            }
            return instance;
        }
    };
})();

// 测试懒汉式单例
console.log('=== 懒汉式单例测试 ===');
const lazy1 = LazySingleton.getInstance();
const lazy2 = LazySingleton.getInstance();
console.log('懒汉式单例相等:', lazy1 === lazy2); // true

const lazyConfig1 = LazyConfigManager.getInstance();
const lazyConfig2 = LazyConfigManager.getInstance();
console.log('懒汉式配置管理器相等:', lazyConfig1 === lazyConfig2); // true
```

**懒汉式特点：**

- ✅ 延迟加载，节省内存
- ✅ 按需创建实例
- ❌ 需要处理线程安全问题
- ❌ 获取实例速度相对较慢

### 1.3 线程安全的懒汉式单例

```javascript
// 线程安全的懒汉式单例
class ThreadSafeLazySingleton {
    static instance = null;
    static lock = false;
  
    constructor() {
        if (ThreadSafeLazySingleton.instance) {
            return ThreadSafeLazySingleton.instance;
        }
      
        this.data = [];
        ThreadSafeLazySingleton.instance = this;
        console.log('线程安全懒汉式单例已创建');
        return this;
    }
  
    static getInstance() {
        if (!ThreadSafeLazySingleton.instance) {
            // 模拟线程安全检查
            if (!ThreadSafeLazySingleton.lock) {
                ThreadSafeLazySingleton.lock = true;
                ThreadSafeLazySingleton.instance = new ThreadSafeLazySingleton();
                ThreadSafeLazySingleton.lock = false;
            }
        }
        return ThreadSafeLazySingleton.instance;
    }
  
    addData(item) {
        this.data.push(item);
    }
  
    getData() {
        return this.data;
    }
}

// 双重检查锁定模式 (Double-Checked Locking)
class DoubleCheckedSingleton {
    static instance = null;
    static lock = false;
  
    constructor() {
        if (DoubleCheckedSingleton.instance) {
            return DoubleCheckedSingleton.instance;
        }
      
        this.data = [];
        DoubleCheckedSingleton.instance = this;
        console.log('双重检查单例已创建');
        return this;
    }
  
    static getInstance() {
        // 第一次检查
        if (!DoubleCheckedSingleton.instance) {
            // 加锁
            if (!DoubleCheckedSingleton.lock) {
                ThreadSafeLazySingleton.lock = true;
                // 第二次检查
                if (!DoubleCheckedSingleton.instance) {
                    DoubleCheckedSingleton.instance = new DoubleCheckedSingleton();
                }
                ThreadSafeLazySingleton.lock = false;
            }
        }
        return DoubleCheckedSingleton.instance;
    }
  
    addData(item) {
        this.data.push(item);
    }
  
    getData() {
        return this.data;
    }
}
```

### 1.4 单例模式的现代实现

```javascript
// ES6 模块单例 (推荐)
// singleton.js
class ModernSingleton {
    constructor() {
        this.data = [];
        console.log('现代单例已创建');
    }
  
    addData(item) {
        this.data.push(item);
    }
  
    getData() {
        return this.data;
    }
}

// 创建单例实例
const singletonInstance = new ModernSingleton();

// 导出单例实例
export default singletonInstance;

// 使用方式
// import singleton from './singleton.js';
```

### 1.5 单例模式的应用场景

```javascript
// 1. 全局配置管理
class AppConfig {
    static instance = null;
  
    constructor() {
        if (AppConfig.instance) {
            return AppConfig.instance;
        }
      
        this.config = {
            apiUrl: 'https://api.example.com',
            timeout: 5000,
            debug: false
        };
      
        AppConfig.instance = this;
        return this;
    }
  
    static getInstance() {
        if (!AppConfig.instance) {
            AppConfig.instance = new AppConfig();
        }
        return AppConfig.instance;
    }
  
    get(key) {
        return this.config[key];
    }
  
    set(key, value) {
        this.config[key] = value;
    }
}

// 2. 数据库连接池
class DatabasePool {
    static instance = null;
  
    constructor() {
        if (DatabasePool.instance) {
            return DatabasePool.instance;
        }
      
        this.connections = [];
        this.maxConnections = 10;
        DatabasePool.instance = this;
        return this;
    }
  
    static getInstance() {
        if (!DatabasePool.instance) {
            DatabasePool.instance = new DatabasePool();
        }
        return DatabasePool.instance;
    }
  
    getConnection() {
        if (this.connections.length < this.maxConnections) {
            const connection = { id: Date.now(), status: 'available' };
            this.connections.push(connection);
            return connection;
        }
        throw new Error('连接池已满');
    }
  
    releaseConnection(connection) {
        const index = this.connections.findIndex(conn => conn.id === connection.id);
        if (index !== -1) {
            this.connections[index].status = 'available';
        }
    }
}

// 3. 日志管理器
class Logger {
    static instance = null;
  
    constructor() {
        if (Logger.instance) {
            return Logger.instance;
        }
      
        this.logs = [];
        Logger.instance = this;
        return this;
    }
  
    static getInstance() {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }
  
    log(message, level = 'info') {
        const logEntry = {
            timestamp: new Date(),
            message,
            level
        };
        this.logs.push(logEntry);
        console.log(`[${level.toUpperCase()}] ${message}`);
    }
  
    getLogs() {
        return this.logs;
    }
}
```

### 1.6 单例模式对比总结


| 特性       | 饿汉式           | 懒汉式             | 线程安全懒汉式 |
| ---------- | ---------------- | ------------------ | -------------- |
| 初始化时机 | 类加载时         | 首次使用时         | 首次使用时     |
| 线程安全   | ✅               | ❌                 | ✅             |
| 内存占用   | 高               | 低                 | 低             |
| 获取速度   | 快               | 慢                 | 中等           |
| 实现复杂度 | 简单             | 简单               | 复杂           |
| 适用场景   | 实例小、使用频繁 | 实例大、使用不频繁 | 多线程环境     |

### 1.7 最佳实践建议

1. **优先使用饿汉式**：如果单例对象较小，且创建和销毁的开销不大
2. **考虑懒汉式**：如果单例对象较大，且创建和销毁的开销较大
3. **多线程环境**：使用线程安全的懒汉式或双重检查锁定
4. **现代开发**：优先使用ES6模块单例，更简洁且天然线程安全
5. **避免过度使用**：单例模式可能导致全局状态，增加代码复杂度

```javascript
// 测试所有单例模式
console.log('=== 单例模式完整测试 ===');

// 饿汉式测试
const eagerSingleton1 = EagerSingleton.getInstance();
const eagerSingleton2 = EagerSingleton.getInstance();
console.log('饿汉式单例测试:', eagerSingleton1 === eagerSingleton2);

// 懒汉式测试
const lazySingleton1 = LazySingleton.getInstance();
const lazySingleton2 = LazySingleton.getInstance();
console.log('懒汉式单例测试:', lazySingleton1 === lazySingleton2);

// 应用场景测试
const config = AppConfig.getInstance();
config.set('debug', true);
console.log('配置测试:', config.get('debug'));

const logger = Logger.getInstance();
logger.log('这是一条测试日志');
console.log('日志数量:', logger.getLogs().length);
```

## 2. 工厂模式 (Factory Pattern)

创建对象的接口，但让子类决定实例化哪个类。

```javascript
// 简单工厂模式
class AnimalFactory {
  static createAnimal(type, name) {
    switch (type) {
      case 'dog':
        return new Dog(name);
      case 'cat':
        return new Cat(name);
      case 'bird':
        return new Bird(name);
      default:
        throw new Error('未知的动物类型');
    }
  }
}

class Dog {
  constructor(name) {
    this.name = name;
    this.type = 'dog';
  }
  
  speak() {
    return `${this.name} says woof!`;
  }
}

class Cat {
  constructor(name) {
    this.name = name;
    this.type = 'cat';
  }
  
  speak() {
    return `${this.name} says meow!`;
  }
}

// 使用
const dog = AnimalFactory.createAnimal('dog', 'Buddy');
const cat = AnimalFactory.createAnimal('cat', 'Whiskers');
console.log(dog.speak()); // Buddy says woof!
console.log(cat.speak()); // Whiskers says meow!
```

## 3. 发布订阅模式 (Observer Pattern)

定义对象间的一对多依赖关系，当一个对象改变状态时，所有依赖者都会收到通知。

```javascript
// 发布-订阅模式实现观察者模式
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  // 订阅事件
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  
  // 发布事件
  emit(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(...args));
    }
  }
  
  // 取消订阅
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
  
  // 一次性订阅
  once(event, callback) {
    const onceWrapper = (...args) => {
      callback(...args);
      this.off(event, onceWrapper);
    };
    this.on(event, onceWrapper);
  }
}

// 使用示例
const emitter = new EventEmitter();

// 订阅
emitter.on('user:login', (user) => {
  console.log(`用户 ${user.name} 已登录`);
});

emitter.on('user:logout', (userId) => {
  console.log(`用户 ${userId} 已退出`);
});

// 发布
emitter.emit('user:login', { name: 'Alice', id: 1 });
emitter.emit('user:logout', 1);
```

## 4. 装饰器模式 (Decorator Pattern)

动态地给对象添加新功能，而不改变其结构。

```javascript
// 函数装饰器
function logDecorator(target, propertyName, descriptor) {
  const method = descriptor.value;
  
  descriptor.value = function(...args) {
    console.log(`调用 ${propertyName} 方法，参数:`, args);
    const result = method.apply(this, args);
    console.log(`${propertyName} 方法返回:`, result);
    return result;
  };
  
  return descriptor;
}

class Calculator {
  @logDecorator
  add(a, b) {
    return a + b;
  }
  
  @logDecorator
  multiply(a, b) {
    return a * b;
  }
}

// 手动实现装饰器
function withLogging(fn) {
  return function(...args) {
    console.log(`调用函数 ${fn.name}，参数:`, args);
    const result = fn.apply(this, args);
    console.log(`函数 ${fn.name} 返回:`, result);
    return result;
  };
}

const originalAdd = (a, b) => a + b;
const loggedAdd = withLogging(originalAdd);
loggedAdd(2, 3); // 调用函数 originalAdd，参数: [2, 3]
```

## 5. 策略模式 (Strategy Pattern)

定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。

```javascript
// 支付策略
class PaymentStrategy {
  pay(amount) {
    throw new Error('必须实现 pay 方法');
  }
}

class CreditCardStrategy extends PaymentStrategy {
  constructor(cardNumber, cvv, expiryDate) {
    super();
    this.cardNumber = cardNumber;
    this.cvv = cvv;
    this.expiryDate = expiryDate;
  }
  
  pay(amount) {
    return `使用信用卡支付 $${amount}`;
  }
}

class PayPalStrategy extends PaymentStrategy {
  constructor(email, password) {
    super();
    this.email = email;
    this.password = password;
  }
  
  pay(amount) {
    return `使用 PayPal 支付 $${amount}`;
  }
}

class AlipayStrategy extends PaymentStrategy {
  constructor(account) {
    super();
    this.account = account;
  }
  
  pay(amount) {
    return `使用支付宝支付 ¥${amount}`;
  }
}

// 上下文类
class ShoppingCart {
  constructor() {
    this.items = [];
    this.paymentStrategy = null;
  }
  
  setPaymentStrategy(strategy) {
    this.paymentStrategy = strategy;
  }
  
  addItem(item) {
    this.items.push(item);
  }
  
  calculateTotal() {
    return this.items.reduce((total, item) => total + item.price, 0);
  }
  
  checkout() {
    const total = this.calculateTotal();
    if (!this.paymentStrategy) {
      throw new Error('请选择支付方式');
    }
    return this.paymentStrategy.pay(total);
  }
}

// 使用
const cart = new ShoppingCart();
cart.addItem({ name: '商品1', price: 100 });
cart.addItem({ name: '商品2', price: 200 });

// 使用不同支付策略
cart.setPaymentStrategy(new CreditCardStrategy('1234', '123', '12/25'));
console.log(cart.checkout()); // 使用信用卡支付 $300

cart.setPaymentStrategy(new PayPalStrategy('user@example.com', 'password'));
console.log(cart.checkout()); // 使用 PayPal 支付 $300
```

## 6. 代理模式 (Proxy Pattern)

为其他对象提供一种代理以控制对这个对象的访问。

```javascript
// 虚拟代理 - 延迟加载图片
class RealImage {
  constructor(url) {
    this.url = url;
    this.loadImage();
  }
  
  loadImage() {
    console.log(`加载图片: ${this.url}`);
    // 模拟图片加载
  }
  
  display() {
    console.log(`显示图片: ${this.url}`);
  }
}

class ImageProxy {
  constructor(url) {
    this.url = url;
    this.realImage = null;
  }
  
  display() {
    if (!this.realImage) {
      this.realImage = new RealImage(this.url);
    }
    this.realImage.display();
  }
}

// 保护代理 - 权限控制
class RealDocument {
  constructor(content) {
    this.content = content;
  }
  
  read() {
    return this.content;
  }
  
  write(content) {
    this.content = content;
  }
}

class DocumentProxy {
  constructor(document, userRole) {
    this.document = document;
    this.userRole = userRole;
  }
  
  read() {
    return this.document.read();
  }
  
  write(content) {
    if (this.userRole === 'admin') {
      return this.document.write(content);
    } else {
      throw new Error('权限不足，无法写入文档');
    }
  }
}

// 使用示例
const proxyImage = new ImageProxy('large-image.jpg');
proxyImage.display(); // 只有在需要时才加载图片

const document = new RealDocument('机密文档');
const adminProxy = new DocumentProxy(document, 'admin');
const userProxy = new DocumentProxy(document, 'user');

console.log(adminProxy.read()); // 可以读取
adminProxy.write('新内容');     // 可以写入

try {
  userProxy.write('恶意修改');   // 权限不足，抛出错误
} catch (error) {
  console.log(error.message);
}
```

## 7. 适配器模式 (Adapter Pattern)

将一个类的接口转换成客户希望的另一个接口。

```javascript
// 旧接口
class OldPaymentSystem {
  makePayment(amount, cardInfo) {
    return `使用旧系统处理支付: $${amount}, 卡号: ${cardInfo.cardNumber}`;
  }
}

// 新接口需求
class NewPaymentProcessor {
  process(amount, paymentMethod) {
    throw new Error('必须实现 process 方法');
  }
}

// 适配器
class PaymentAdapter extends NewPaymentProcessor {
  constructor(oldSystem) {
    super();
    this.oldSystem = oldSystem;
  }
  
  process(amount, paymentMethod) {
    // 将新接口转换为旧接口
    const cardInfo = {
      cardNumber: paymentMethod.cardNumber,
      cvv: paymentMethod.cvv
    };
    return this.oldSystem.makePayment(amount, cardInfo);
  }
}

// 使用
const oldSystem = new OldPaymentSystem();
const adapter = new PaymentAdapter(oldSystem);

const result = adapter.process(100, {
  cardNumber: '1234-5678-9012-3456',
  cvv: '123'
});

console.log(result); // 使用旧系统处理支付: $100, 卡号: 1234-5678-9012-3456
```

## 8. 命令模式 (Command Pattern)

将请求封装成对象，从而使你可以用不同的请求对客户进行参数化。

```javascript
// 命令接口
class Command {
  execute() {
    throw new Error('必须实现 execute 方法');
  }
  
  undo() {
    throw new Error('必须实现 undo 方法');
  }
}

// 具体命令
class AddTextCommand extends Command {
  constructor(editor, text) {
    super();
    this.editor = editor;
    this.text = text;
    this.position = editor.content.length;
  }
  
  execute() {
    this.editor.content += this.text;
    return this.editor.content;
  }
  
  undo() {
    this.editor.content = this.editor.content.substring(0, this.position);
    return this.editor.content;
  }
}

class DeleteTextCommand extends Command {
  constructor(editor, length) {
    super();
    this.editor = editor;
    this.length = length;
    this.deletedText = '';
  }
  
  execute() {
    this.deletedText = this.editor.content.slice(-this.length);
    this.editor.content = this.editor.content.substring(0, 
      this.editor.content.length - this.length);
    return this.editor.content;
  }
  
  undo() {
    this.editor.content += this.deletedText;
    return this.editor.content;
  }
}

// 接收者
class TextEditor {
  constructor() {
    this.content = '';
    this.history = [];
  }
  
  executeCommand(command) {
    const result = command.execute();
    this.history.push(command);
    return result;
  }
  
  undo() {
    if (this.history.length > 0) {
      const command = this.history.pop();
      return command.undo();
    }
    return this.content;
  }
}

// 使用
const editor = new TextEditor();

const addHello = new AddTextCommand(editor, 'Hello ');
const addWorld = new AddTextCommand(editor, 'World!');

editor.executeCommand(addHello); // "Hello "
editor.executeCommand(addWorld); // "Hello World!"

editor.undo(); // "Hello "
editor.undo(); // ""
```

## 9. 外观模式 (Facade Pattern)

为复杂的子系统提供一个简单的接口。

```javascript
// 复杂的子系统
class CPU {
  freeze() { console.log('CPU freeze'); }
  jump(position) { console.log(`CPU jump to ${position}`); }
  execute() { console.log('CPU execute'); }
}

class Memory {
  load(position, data) { console.log(`Memory load at ${position}: ${data}`); }
}

class HardDrive {
  read(lba, size) { 
    console.log(`HardDrive read from ${lba}, size: ${size}`);
    return 'bootloader data';
  }
}

// 外观类
class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }
  
  start() {
    console.log('启动计算机...');
    this.cpu.freeze();
    this.memory.load(0, this.hardDrive.read(0, 1024));
    this.cpu.jump(0);
    this.cpu.execute();
    console.log('计算机启动完成');
  }
  
  shutdown() {
    console.log('关闭计算机...');
    // 关闭逻辑
    console.log('计算机已关闭');
  }
}

// 使用
const computer = new ComputerFacade();
computer.start();
// 启动计算机...
// CPU freeze
// HardDrive read from 0, size: 1024
// Memory load at 0: bootloader data
// CPU jump to 0
// CPU execute
// 计算机启动完成
```

## 10. 模块模式 (Module Pattern)

创建私有和公有变量、方法的封装。

```javascript
// 基础模块模式
const CounterModule = (function() {
  let count = 0; // 私有变量
  
  function increment() { // 私有方法
    count++;
  }
  
  function decrement() { // 私有方法
    count--;
  }
  
  return { // 公有接口
    getCount() {
      return count;
    },
  
    add(num) {
      count += num;
      return this; // 支持链式调用
    },
  
    subtract(num) {
      count -= num;
      return this;
    },
  
    reset() {
      count = 0;
      return this;
    }
  };
})();

// 使用
console.log(CounterModule.getCount()); // 0
CounterModule.add(5).subtract(2);
console.log(CounterModule.getCount()); // 3
CounterModule.reset();
console.log(CounterModule.getCount()); // 0

// ES6 模块模式
class DataStore {
  constructor() {
    this._data = new Map(); // 私有数据
  }
  
  set(key, value) {
    this._data.set(key, value);
    return this;
  }
  
  get(key) {
    return this._data.get(key);
  }
  
  has(key) {
    return this._data.has(key);
  }
  
  delete(key) {
    return this._data.delete(key);
  }
  
  clear() {
    this._data.clear();
    return this;
  }
  
  size() {
    return this._data.size;
  }
  
  // 迭代器
  *[Symbol.iterator]() {
    for (let [key, value] of this._data) {
      yield [key, value];
    }
  }
}

const store = new DataStore();
store.set('name', 'Alice').set('age', 25);
console.log(store.get('name')); // Alice
console.log(store.size()); // 2
```

## 11. 组合模式 (Composite Pattern)

将对象组合成树形结构以表示"部分-整体"的层次结构。

```javascript
// 组件接口
class FileSystemComponent {
  constructor(name) {
    this.name = name;
  }
  
  getSize() {
    throw new Error('必须实现 getSize 方法');
  }
  
  getInfo() {
    throw new Error('必须实现 getInfo 方法');
  }
}

// 叶子节点 - 文件
class File extends FileSystemComponent {
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  
  getSize() {
    return this.size;
  }
  
  getInfo() {
    return `${this.name} (文件, ${this.size}KB)`;
  }
}

// 组合节点 - 文件夹
class Folder extends FileSystemComponent {
  constructor(name) {
    super(name);
    this.children = [];
  }
  
  add(component) {
    this.children.push(component);
  }
  
  remove(component) {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }
  
  getSize() {
    return this.children.reduce((total, child) => total + child.getSize(), 0);
  }
  
  getInfo() {
    const childrenInfo = this.children.map(child => child.getInfo()).join('\n  ');
    return `${this.name} (文件夹, ${this.getSize()}KB)\n  ${childrenInfo}`;
  }
}

// 使用
const root = new Folder('项目');

const src = new Folder('src');
const docs = new Folder('docs');

const mainFile = new File('main.js', 100);
const utilsFile = new File('utils.js', 50);
const readmeFile = new File('README.md', 10);

src.add(mainFile);
src.add(utilsFile);
docs.add(readmeFile);

root.add(src);
root.add(docs);

console.log(root.getInfo());
// 项目 (文件夹, 160KB)
//   src (文件夹, 150KB)
//     main.js (文件, 100KB)
//     utils.js (文件, 50KB)
//   docs (文件夹, 10KB)
//     README.md (文件, 10KB)

console.log(`总大小: ${root.getSize()}KB`); // 总大小: 160KB
```

## 设计模式选择指南


| 模式   | 适用场景                     |
| ------ | ---------------------------- |
| 单例   | 全局配置、缓存、日志对象     |
| 工厂   | 创建相似对象、解耦创建逻辑   |
| 观察者 | 事件处理、数据绑定、状态管理 |
| 装饰器 | 动态添加功能、AOP编程        |
| 策略   | 算法切换、表单验证、支付方式 |
| 代理   | 延迟加载、权限控制、远程代理 |
| 适配器 | 接口兼容、第三方库集成       |
| 命令   | 撤销操作、队列处理、宏命令   |
| 外观   | 简化复杂API、第三方库封装    |
| 模块   | 代码组织、封装私有状态       |
| 组合   | 树形结构、递归处理           |

这些设计模式在实际开发中经常使用，掌握它们有助于编写更优雅、可维护的代码。
